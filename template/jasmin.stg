group jasmin;

prog(name, funclist, datalist, tam) ::= <<
.source <name>.j
.class public <name>
.super java/lang/Object

    <datalist>

    <funclist>

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic <name>/_main()V
        return
    .end method
>>

funclist(funcs) ::= <<
<funcs; separator="\n\n">
>>

datalist(datas) ::= <<
<datas; separator="\n\n">
>>

data(name, declist) ::= <<
.class public <name>
.super java/lang/Object
<declist>
>>

declist(decls) ::=<<
<decls; separator="\n">
>>

decl(classname, type, name) ::=<<
.field public <name> <type>
>>

var_decl(type, name) ::=<<
<type> <name>;
>>

paramslist(params) ::= <<
<params; separator=", ">
>>


cmdlist(cmds, variables) ::= <<
<variables; separator="\n">
<cmds; separator="\n">
>>

func(returntypes, name, paramslist, cmdlist, stack, decls) ::= <<
.method public static <name>(<paramslist>)<returntypes>
    .limit stack <stack>
    .limit locals <decls>
    <cmdlist>
    return
.end method
>>

func2(type, name, params, decl, stmt) ::= <<
static <type> <name>(<params; separator=", ">)
    <if(decl)><decl; separator=";\n">;<endif>
    <stmt>
>>

param(type, id) ::= "<type> <id>"
multiple_returns() ::= "List\<Object>"
array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
string_type() ::= "Ljava/lang/String"

print2(expr) ::= "System.out.print(<expr>);"

print(expr, type) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/print(<type>)V
>>

return(expr) ::= "return <expr>;"
read(lvalue) ::= "read <lvalue>;"

iterate(expr, cmdlist, unique_id) ::= <<
int cont<unique_id> =0;
while(cont<unique_id> \< <expr>){
    <cmdlist>
    cont<unique_id>++;
}
>>

if(unique_id, expr, thn, els) ::= <<
<expr>
iconst_1
if_icmpeq #THEN<unique_id>
goto #ELSE<unique_id>
#THEN<unique_id>:
    <thn>
    goto #ENDIF<unique_id>
#ELSE<unique_id>:
    <els>
#ENDIF<unique_id>:
>>

stmt_list(stmt1, stmt2) ::= <<
<stmt1>
<stmt2>
>>

attr(id, expr, type) ::= "<id> = <if(type)>(<type>)<endif><expr>;"
lvalue(lvalue, expr) ::= "<lvalue><if(expr)>.get(<expr>)<endif>"
lvalue_attribute(lvalue, attr) ::= "<lvalue>.<attr>"

boolean_expr(value) ::= "<value>"
float_expr(value) ::= "<value>"
int_expr(value) ::= "<value>"

new_array(type, expr) ::= "initialize(<expr>,new ArrayList\<<type>>(<expr>))"
new_object(type) ::= "new <type>()"
array(type) ::= "ArrayList\<<type>>"

call(name, args, return) ::= <<
List\<Object> arr = new ArrayList\<Object>();
arr = <name>(<args; separator=", ">);
<return; separator="\n">
>>

callvet(name, args, expr) ::= <<<name>(<args; separator=", ">).get(<expr>)>>

attrReturn(name, expr, type) ::= << <name> = (<type>)arr.get(<expr>);>>

mul_expr(prefix, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
<prefix>mul
>>

div_expr(prefix, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
<prefix>div
>>

mod_expr(prefix, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
<prefix>rem
>>

add_expr(prefix, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
<prefix>add
>>

sub_expr(prefix, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
<prefix>sub
>>

sub_uni_expr(prefix, expr) ::= <<
<prefix>const_0
<expr>
<prefix>sub
>>

comparison(unique_id, left_expr, right_expr, name) ::= <<
<left_expr>
<right_expr>
<name> #THEN<unique_id>
goto #ELSE<unique_id>
#THEN<unique_id>:
    iconst_1
    goto #ENDIF<unique_id>
#ELSE<unique_id>:
    iconst_0
#ENDIF<unique_id>:
>>

lt_expr(unique_id, left_expr, right_expr) ::= <<
<comparison(unique_id, left_expr, right_expr, "if_icmplt")>
>>

gt_expr(unique_id, left_expr, right_expr) ::= <<
<comparison(unique_id, left_expr, right_expr, "if_icmpgt")>
>>

equals_expr(unique_id, left_expr, right_expr) ::= <<
<comparison(unique_id, left_expr, right_expr, "if_icmpeq")>
>>

diff_expr(unique_id, left_expr, right_expr) ::= <<
<comparison(unique_id, left_expr, right_expr, "if_icmpne")>
>>


and_expr(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
imul
>>

not_expr(unique_id, expr) ::=<<
<expr>
iconst_1
if_icmpeq #THEN<unique_id>
goto #ELSE<unique_id>
#THEN<unique_id>:
    iconst_0
    goto #ENDIF<unique_id>
#ELSE<unique_id>:
    iconst_1
#ENDIF<unique_id>:
>>

push_stack(value) ::= "ldc <value>"
iconst(value) ::= "iconst_<value>"